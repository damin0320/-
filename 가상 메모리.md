> [내용정리](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5)

# 가상메모리가 뭐야?

프로그래밍을 동시다발적으로 하려면 프로세스를 동시에 메모리에 막 올려둬야 하는데 그 때 가상메모리가 큰 역할을 한다. "프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법"

한마디로 가상메모리 덕에 프로세스 역할이 확 줄어든다? 뭐 이렇게 이해하면 될 것 같다.

### 1. 배경
- 원래는 실행되는 모든 코드는 물리적 메모리에서만 가능했고 그것보다 크면 돌아갈 수 없었음
- **효율성을 위해서 프로그램의 일부분만 메모리에 올릴 수 있다면...?**
-> 물리메모리 제약X / 더 많은 프로그램 동시에 실행 / Swap제한 X

### 2. 가상메모리가 뭘 할까? ; 논리 메모리 &(+페이지 테이블) 물리 메모리

1. 가상 메모리는 "실제 물리 메모리 개념과 사용자의 논리 메모리 개념 분리한 것으로 정의" 때문에 작은 메모리 가지고도 얼마든지 가상 주소 공간을 프로그래머에게 제공할 수 있다.

2. 뿐만 아니라 실제 메모리를 차지하는 것이 아니기 때문에 필요할 때 불러서 쓸 수 있어 메모리를 아낄 수 있다.

3. 가상메모리는 프로세스 간 페이지를 공유할 수 있게 해준다.
> 이 부분에 대한 자세한 설명은 잘 이해가 되진 않는다.

### 3. Demand Paging(요구 페이징) : 요구되는 페이지만 올린다.
- "프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략"
-> 다 끌어 오는게 아니라 필요한 것만 적재

- "프로세스 내의 개별 페이지들은 페이저(pager)에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로서, 사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다."
-> 필요한 것만 읽어오니까 시간 낭비나 메모리 낭비를 줄일 수 있다는 뜻.

### 4. 페이지 교체
- Page falut trap : 페이지에서 필요한 것만 가져오다 보니 페이지 부재 트랩이 발생한다는 뜻. 이럴 경우에는 원하는 페이지를 보조저장장치에서 가져오게 된다.
- 근데 물리메모리가 모두 사용중이라면..? : 페이지 자체가 교체가 이뤄져야 한다.

#### 1. HOW?
1. 디스크에서 필요한 페이지의 위치를 찾는다
2. 빈 페이지 프레임을 찾는다.
3. 페이지 교체 알고리즘을 통해 희생될(victim) 페이지를 고른다.
 - 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
 - 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

> 어렵다. 눈으로 보이지 않아서 그런지 쉽지 않다.

#### 2. 알고리즘 : 이런게 있구나 정도만 일단 이해하기
1. FIFO
2. LRU
3. LFU
4. MFU

[찾아서 볼 링크](https://velog.io/@gndan4/OS-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC#%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95-demand-paging-%EB%98%90%EB%8A%94-demanded-paging)
