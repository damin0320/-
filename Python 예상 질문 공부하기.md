# Python

**<Question 1> PYTHONPATH가 무엇인가?**
  - import 할 때 기존 라이브러리 외 추가적으로 파이썬이 찾아보는 디렉토리 path
  
**<Question 2> Generator에 대해 설명해 달라**
[참고 링크](https://bluese05.tistory.com/56)

- 이터레이터가 클래스를 이용하여 이터러블 객체를 생성하는 것이라면 제너레이터는 이터레이터를 생성해주는 함수. yield를 사용
- 코루틴(yield)이자 이터레이터의 한 종류. 함수를 사용할 때 함수를 멈췄다가 다시 재생시켰다 할 수 있다.
- 리스트와 다르게 제네레이터는 값을 전부 메모리에 저장하지 않는데 next()가 불렸을 때만 그 다음 값이 생성되기 때문에 큰 메모리를 필요로 하는 값, 그리고 지금 당장 리스트가 필요하지 않은 값은 제네레이터를 사용하는게 효율적.
![](https://images.velog.io/images/sinichy7/post/e3e03f0a-98a6-4106-8fc5-cb76972d4122/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-06-14%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.04.50.png)
- 추가로 수행 시간이 긴 연산을 필요한 순간까지 늦출 수 있다고 함.

- 단점 : 한번 이터레이트 오버하면 더 이상 사용할 수 없다.(재사용이 안 된다.)

**<Question 3> Closure와 decorator에 대해 설명해 달라**
1. closure : 함수를 감싸고 있는 함수의 형태. 클래스와 비슷한데 간단할 때 사용할 때는 클로져가 간결할 수 있다. Data-hiding 과 global 변수를 제외할 수 있는 방법.
2. decorator : 클로져 형태를 띈 함수 혹은 클래스의 기능을 더 추가해주는 툴.
- 사용 이유 : 다른 함수들에 적용이 가능하기 때문에 재사용성이 좋다. 시간 계산하거나 무언가를 실행하기 전에 미리 실행해야 하는게 있다면 데코레이터 사용하면 된다.
- @wraps라는 함수적 툴 기능 추가해야 할 때 있는데 데코레이터 체이닝할 때 리턴되는 값이 이전 데코레이터가 아니라 원래 함수 값으로 항상 정해주기 위함.(리턴값이 랩값이 아니라 원래 함수의 값이 리턴되어야 한다.)

**<Question 4> Multiple assignment와 packing/unpacking에 대해 설명해 달라.**
- 다른 언어와 달리 파이썬은 변수 선언 없이 x,y = y,x가 된다. 이유는 이런 값들을 튜플로 묶어서 이를 LOOP하고 값을 지정하기 때문. (x,y) = y, x와 같은 것.

**<Question 5> 파이썬은 compiled 된 언어인가 interpreted 언어인가?**
파이썬은 인터프리터 언어다. bytecode로 변환되고 -> python virtual machine이 인터프리터해서 실행된다.

**<Question 6> Garbage Collection(GC)에 대해 설명해 달라.**
- 프로그램이 더 이상 필요없는 메모리를 제거함으로써 메모리를 비워주는 행위.
(managed language에서만 함.)

[참고영상](https://youtu.be/24f2-eJAeII)

(대표적인 두 가지 방법론)
#### 1. 레퍼런스 카운팅 : 
"한 요소가 다른 요소에게 몇 번이나 참조되는지 확인한 다음 레퍼런스 카운트가 0이 되면 객체를 지운다." -> 연결 안 되어서 카운트 0되면 다 버린다.
- 장점 : 구현하기 쉽고 0이 되지마자 메모리를 비워준다.
- 단점 : 레퍼런스 카운트를 하기 위한 저장공간이 필요하고 매 명령마다 레퍼런스 바꿔야하는 오버헤드

>data = [1,2,3,4,5] # 변수명 data가 [1,2,3,4,5] 리스트를 참조(레퍼런스)한다.

>data = [1,2,3,4,5]
data = 'test' # 변수명 data가 'test' 문자열을 참조(레퍼런스)한다.

>rc를 보게 되면, [1,2,3,4,5]의 rc는 1이었다가 data가 test를 받는 순간 0이 된다.
이렇게 됐을 때, [1,2,3,4,5]는 아무것도 참조받지 않으며, 소멸 대상이 된다.

#### 2. 제네레이셔널 가비지 컬렉션 : 
"마크 앤 스윕"이라는 트래이싱 기법
- stack 등 참조되고 있는 필요한 객체들 모두 찾아서 마킹한 후(마크) 마킹되지 않은 객체들을 heap에서 제거한다.(스윕) : 루트에서 연결이 되지 않은 것들을 다 치운다

> 조리대에서 필요 없는 재료를 버린다.

- 가비지 컬렉터의 한계 : 지워야 할 것들을 100% 잡아내진 못한다. -> 언어, 플랫폼마다 바람직한 메모리 관리 방식을 알고 있어야 한다.


**<Question 7> GIL에 대해 설명해 달라.**
- Global Interpreter Lock, 파이썬 인터프리터와 관련된 락을 의미한다.
- 파이썬이 하나의 쓰레드에서만 작동되도록 잠그는 역할(멀티스레딩 상황에서 단 하나의 스레드만 접근할 수 있도록 하는 것)
- 이유 : 효율적인 "레퍼런스 카운팅"을 할 수 있기 때문
-> 레퍼런스 카운팅은 쓰레드-세이프 하지 않기 때문에 여러 쓰레드에 레퍼런스 카운팅을 하면 속도가 느려진다.

e.g. 자원을 공유한 스레드 1, 2
스레드1 : 변수 x가 RC가 0이니 지워버릴까? -> 스레드2가 x가 필요해서 접근 -> 왜 지워졌지?! : 이런 상황을 GIL로 통제한다.(한 스레드만 접근할 수 있게)

> 그래서 파이썬에서는 멀티쓰레딩보다는 멀티 프로세싱이 조금 더 효율적이다.

**<Question 8> 파이썬 namespace에 대해 설명해 달라.**

[참고 링크](https://hcnoh.github.io/2019-01-30-python-namespace)

- dict에 key:value처럼 name:object로 객체를 매핑하는 공간. -> 객체를 이름에 따라 구분하는 범위를 의미

쓰는 이유 : 
> 따라서 프로그래밍언어에서는 네임스페이스라는 개념을 도입하여, 특정한 하나의 이름이 통용될 수 있는 범위를 제한한다. 즉, 소속된 네임스페이스가 다르다면 같은 이름이 다른 개체를 가리키도록 하는 것이 가능해진다.

- 크게 네 가지 namespace: built-in, global, enclosed, local
- 더 낮은 단계에 있는 공간에 접근은 가능하지만 반대로는 불가능.

![](https://images.velog.io/images/sinichy7/post/3ff6f4d0-fcb5-450e-8ef4-f82519ba75bb/image.png)

**<Question 9> Testing과 관련된 Unittest, PyTest - 테스트를 하는 이유, 테스트 기능들 설명.**

1) 가장 먼저는 test fixture 인데 → 테스트를 하기 위한 준비(프록시 디비, 서버 프로세스 생성, 등)
2) test case 는 단일 테스트 유닛이다 → 입력된 값이 특정 응답과 맞는지 확인
3) 여러 테스트 케이스들이 모여서 test suite 들이 모인다 → 같이 테스트되야 되는 것들
4) 파이썬에는 다양한 test runner 들이 존재한다 → unittest, nose, pytest

> 이 부분은 실제로 사용해보면 더 이해가 잘 될듯. unit test한 내용 기억해두기.

**<Question 10> 객체지향이란 무엇이고 파이썬은 객체지향 언어인가?**

1. 객체지향이란? : "객체를 중심으로 프로그램을 만드는 것을 의미한다. 한 객체 안에는 그 객체에 대한 속성과 행동을 정의"
2. 객체지향의 4요소
- 추상화
- 캡슐화
- 상속
- 다형성
3. 파이썬은 객체지향 언어이다.
- 위의 4가지 요소가 모두 통용된다.
- 차이 : 메서드 오버로딩은 되지 않는다.(오버 라이딩만 가능)

**<Question 11> Memory management는 어떻게 이루어지는가?**
- 파이썬은 메모리 메니저를 사용하고 개발자에겐 직접적인 메모리 권한이 없다.
- 실행되면 스텍 메모리와 힙 메모리가 실행에 필요한 메모리를 담당한다. 스텍에는 main 혹은 유저가 선언한 함수들이 스택으로 쌓이고, heap에서는 그 함수에서 레퍼런스 하는 값들이 저장된다.

> 프로세서에서 메모리가 작동하던 4가지 요소 생각해보기

**<Question 12> 파이썬에서 memory leak?**

***"비워줘야할 메모리 공간을 깜빡 놓치고 남겨놓는 일, 이를 메모리 누수, 메모리 릭이라 부른다"***

-> 가비지 컬렉터가 왜 필요한지 설명할 수 있는 원인

- 메모리 릭은 더 이상 사용 않는 객체가 GC되지 않고 살아남을 때 불필요한 객체를 컴파일하는 행위. (즉 안 지워지고 컴파일 되어버린다는 뜻) 물론 파이썬에서는 자체적으로 GC가 해결해주므로 신경 안 써도 되긴 하지만 만일 생긴다면 다음과 같이 해결해야 한다.
- GC 빌트인 모듈에서 현재 trace하고 있는 객체들을 모두 나열해서 문제 점검해봐도 되고, tracemalloc을 통해 객체들의 정보를 보면서 직접 지워줘야 한다.

**<Question 13> @staticMethod, @classMethod, @property에 대해 설명해 달라.**
 > 정적 메소드(클래스를 통해 직접 접근할 수 있는 메소드), 둘 다 인스턴스를 만들지 않아도 클래스의 메서드를 바로 실행할 수 있다.

- @staticMethod : 상속에서 차이가 나는데 부모 클래스의 클래스 속성 값을 가져옴
- @classMethod : 클래스 인자를 활용하여 현재 클래스의 클래스 속성을 가져온다.
- @property : 클래스에서 메서드를 통하여 속성의 값을 가져오거나 저장하는 경우에 사용(가져오는 것은 getter, 저장하는 건 setter, 이를 간단히 구현하는 것이 @property) 

**<Question 14> 왜 pypy가 CPython보다 빠른가?**
- pypy는 JIT(기계어나 로우 언어 자동 번역하는 컴파일러 기능을 포함하고 있음)를 활용하는데 이를 이용해서 컴파일을 런타임하기 때문에 AOT보다 유리.

- AOT? : 목표 시스템의 기계어와 무관하게 중간 언어 형태로 배포된 후 목표 시스템에서 인터프리터나 JIT 컴파일 등 기계어 번역을 통해 실행되는 중간 언어를 미리 목표 시스템에 맞는 기계어로 번역하는 방식을 지칭
-> 여기서는 바이트코드가 중간언어. 즉 한 번 더 걸쳐서 하기 때문에 pypy가 조금 더 빠르다고 볼 수 있다. + JIT가 로우 언어를 자동 번역해주는 기능이 있음
